<template lang="pug">
  .my-node-page
    main
      back-nav(title='PWA Configuration')
      section.section
        .container
          .content
            | In this section of the tutorial we'll discuss what's involved in a PWA...

          .title.is-4 Understanding PWA

          .content
            | There's lots of information available on the Web about PWA's so I won't try to duplicate that
            | here. Here's some of the links you can take a look at:  

            ul
              li 
                a(href='https://developers.google.com/web/progressive-web-apps/') Google Main Page for PWA
              li 
                a(href='https://developers.google.com/web/progressive-web-apps/checklist') Google's PWA checklist
              li 
               a(href='https://developer.mozilla.org/en-US/Apps/Progressive') PWA on MDN

          .content
            | In summary, a PWA is an app that can easily be added to the homescreen and used without a browser bar.  
            | PWA's can also be tuned to do more offline. The app feels and acts more like a Native app.  

          .title.is-4 The Manifest

          .content
            | The Manifest file is used to configure your PWA (not to be confused with your 
            | Webpack Chunk Manifest file). The file gets copied from your 
            code static
            | folder (and also the icons in 
            code static/img/
            |  ):

          strong.my-italic static/manifest.json 
          pre.block
            code.hljs.javascript
              :highlight(lang='javascript')
                {
                  "name": "vue-example-project",
                  "short_name": "example",
                  "icons": [
                    {
                      "src": "/vue-example-project/static/img/icons/android-chrome-192x192.png",
                      "sizes": "192x192",
                      "type": "image/png"
                    },
                    {
                      "src": "/vue-example-project/static/img/icons/android-chrome-512x512.png",
                      "sizes": "512x512",
                      "type": "image/png"
                    }
                  ],
                  "start_url": "/vue-example-project/",
                  "scope": "/vue-example-project/",
                  "display": "standalone",
                  "background_color": "#000000",
                  "theme_color": "#00d1b2"
                }

          .title.is-4 The Service Worker

          .content
            | The Service Worker allows for offline mode and is generated by the Webpack plugin: 

          strong.my-italic build/webpack.prod.conf.js 
          pre.block
            code.hljs.javascript
              :highlight(lang='javascript')
                // ...

                  plugins: [

                    // ...

                    // service worker caching
                    new SWPrecacheWebpackPlugin({
                      cacheId: 'vue-example-project',   // <-- Update this id for your app.
                      filename: 'service-worker.js',
                      staticFileGlobs: ['dist/**/*.{js,html,css}'],
                      minify: true,
                      stripPrefix: 'dist/'
                    })

          .content
            | After you 
            code npm run build
            |  for production you'll see it appear in your 
            code /dist
            | folder.

          .title.is-4 The View Port

          .content
            | The proper view port (so that both desktop and mobile devices scale correctly) has been set
            | via a meta tag in 
            code index.html

          strong.my-italic index.html
          pre.block
            code.hljs.html
              :highlight(lang='html')
                <meta name="viewport" content="width=device-width, initial-scale=1">

          .title.is-4 Setting Up HTTPS
          
          .content
            | To take full advantage of a PWA (so that mobile devices will correctly consider your app a PWA
            | and service works can work) 
            | you will need to serve your app over HTTPS.

          .title.is-6 Create your own Self-Signed SSL for testing on your localhost

          .content You can read how to set up SSL on your localhost nginx server here: 
            a(href='https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-16-04')
              | https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-16-04
            | .

          .title.is-6 CloudFlare Free HTTPS 

          .content
            | CloudFlare offers free HTTPS. Here are the steps you'll need to take: 
            ul
              li 
                | 1. Make sure you setup your-name.github.io to allow for your-custom-domain. You'll go
                | to settings in your-name.github.io repo and add www.your-custom-domain.com there. You'll
                | also need to add a file named 
                code CNAME 
                | that contains www.your-custom-domain.com.
              li 2. Sign up for free CloudFlare account for www.your-custom-domain.com. 
              li 3. Go to CloudFlares DNS tab: 
              ul
                li 
                  | 3.1 Copy CloudFlare's nameservers and go to your registrar (where you purchased your-custom-domain)
                  | and add them there so your registrar will now point to CloudFlare's NameServers to resolve.
                li 
                  | 3.2 Add a flat CNAME rule, for example: 
                  code CNAME * your-name.github.io
                  |  .
              li 
                | 4. Make sure you have turned on SSL. See the section "Domain Summary" in the Overview tab. 
                | Make sure you have it set for 
                code full
                |  .
              li 
                | 5. Go to CloudFlare's Page Rules tab and add the rule 
                code http://*.your-custom-domain.com/* 
                | with settings as 
                code Always Use HTTPS
              li 6. Wait for a few hours (up to 24) and then Github should pick it up and it should work.
              li 7. Turn off CloudFlare cacheing temporarily by turning on "Dev" mode so you can see changes immediately reflected online.

          .title.is-4 Install Banners and Add to Home Screen

          .content
            | You can read about install banners and "Add to Home Screen" here (includes notes on "testing"
            | for them as well): 
            a(href='https://developers.google.com/web/fundamentals/engage-and-retain/app-install-banners/') 
              | https://developers.google.com/web/fundamentals/engage-and-retain/app-install-banners/
            | Basically, it's just a popup indication from the mobile device that allows users to more easily
            | add your app to their homescreen (allows for shortcut and opens without a browser bar).
            | The restrictions are: 
            ul
              li Has a web app manifest file with:
              ul
                li a short_name (used on the home screen)
                li a name (used in the banner)
                li a 144x144 png icon (the icon declarations must include a mime type of image/png)
                li a start_url that loads
              li Has a service worker registered on your site.
              li Is served over HTTPS (a requirement for using service worker).
              li Is visited at least twice, with at least five minutes between visits.

          strong.my-italic index.html
          pre.block
            code.hljs.html
              :highlight(lang='html')
                <meta name="viewport" content="width=device-width, initial-scale=1">


    main-footer

</template>

<script>
import BackNav from '@/features/common/back-nav'

export default {
  name: 'pwa-configuration',

  components: { BackNav },

  mounted () {
    // @TODO: You don't have to do this if you are using "history" mode in VueRouter.
    // I'm doing this here because of GitHub Pages "hash" mode requirement/limitation.
    const titles = Array.from(document.getElementsByClassName('title'))
    const title = titles.filter((el) => el.innerHTML === this.$route.query.title)[0]
    if (title) title.scrollIntoView()
    else scroll(0, 0)
  },

  data () {
    return {

    }
  },

  methods: {
  }
}
</script>
